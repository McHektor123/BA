% Chapter Template

\chapter{Ergebnisse} % Main chapter title

\label{Kaptiel4} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------
\section{Versuchsaufbau}
Für die Berechnung der Anfragen wurde die Dell Precision Workstation T5500 verwendet. Das System besitzt 16 Prozessoren vom Typ Intel Xeon  X5500 mit je 2,66GHz und  8 MB SmartCache. Insgesamt stehen 72 GB DDR3 RAM mit 1333 MHz zur Verfügung und das System läuft auf Ubuntu 18.04. Alle Datensätze werden auf einer SEAGATE ST3250318AS Festplatte mit insgesamt 250 GB Kapazität und 8 MB Cache, gespeichert.\newline
 Jede Anfrage der ersten Iteration wurde 50 mal aufgeführt und die Anfragen der zweiten Iteration wurden 25 mal ausgeführt. In OrientDB wurden alle Anfragen 25 mal wiederholt. Als repräsentativer Wert für die Bearbeitungszeit einer Anfrage  wurde das Arithmetische Mittel aus allen Wiederholungen gewählt. Bei der Berechnung wurde die Zeit für die allererste Ausführung einer Anfrage nicht berücksichtigt, da durch das Caching eine unverhältnismäßig hohe Bearbeitungszeit beim ersten Ausführen beobachtet wurde. Alle Zeitangaben sind in ms angegeben. 
\section{Auswertung}
Im folgenden Abschnitt werden Ausführungszeiten der Iterationen tabellarisch präsentiert.  Darauf aufbauend werden die Vermutungen aus Kapitel 3 überprüft und es wird Bezug auf der beobachtet Verhalten genommen. \newline \newline
Die Ergebnisse für Grundanfrage 1.1 werden  in Tabelle \ref{tab:Query1_1} gezeigt. Wie erwartet ist der Ausführungszeit in allen 3 Szenarien am längsten, wenn die Relationen unabhängig von ihrer Richtung betrachtet werden. Dies ist auf die hohe Zahl der vorhandenen Relationen zurückzuführen. Bei der Anfrage in Cypher und der Core API für die RELATIONSHIP3  ist die Ausführungszeit für die richtungsunabhängige Suche länger als die Suchen mit ausgehenden und eingehenden Kanten addiert. Für die Anfragen mit REELATIONSHIP3 ist wie vermutet, die Zeit am geringsten, wenn die ausgehenden Kanten betrachtet werden. \newline
Die Anfrage für RELATIONSHIP3 wird mit der Core API in  allen Fällen fast doppelt so schnell berechnet wie in Cypher. Dieses Verhalten wird bei den weiteren Grundanfragen ebenfalls erwartet, die Ursachen hierfür wurden in den Kapitel 2 erläutert. \newline
Die Anfragen wurden in Cypher für RELATIONSHIP2 mehr als 1000 mal schneller bearbeitet. Dies deutet auf eine schlechte Skalierbarkeit des Systems hin, da die notwendigen Berechnungen beinahe linear ansteigen. 
\FloatBarrier  
\begin{table}[h]
\centering
\begin{tabular}{ |p{3cm}||p{3cm}|p{3cm}|p{3cm}|  }
	\hline
	Anfrage& RELATIONSHIP3 &Core API&RELATIONSHIP2\\
	\hline
	Eingehend   & 215.383    &123.963&  64\\
	Ausgehend&    212.620  & 82.057   & 160\\
	Beides&496.704 & 222.150&  165\\
	\hline
\end{tabular}
\caption{Grundanfrage 1.1}
\label{tab:Query1_1}
\end{table}
\FloatBarrier
 Die beobachteten Zeiten für Grundanfrage 1.2 in Tabelle \ref{tab:Query1_2} sind im Vergleich zu den Zeiten der anderen Grundanfragen sehr gering. Durch die geringe Anzahl von 50004 Knoten und eine einfache Abbruchbedingung entstehen die geringen Zeiten. \newline Entgegen der Erwartung entsteht ein zeitlicher Unterschied, wenn sich die Bedingung im Where-Prädikat befindet. Die beobachtet Ausführungszeit ist 3-mal schneller, als bei der Anfrage mit der Bedingung im Match-Prädikat. Da der Cypher Query Optimizer alle Bedingungen des Match-Prädikates in ein Where verschiebt, wird hier gezeigt, dass diese Optimierungsschritt selber eine gewisse Berechnungszeit in Anspruch nimmt. Für ein optimalen Gebrauch von Neo4j sollten dementsprechend alle Bedingungen direkt in einem Where-Prädikat formuliert werden, dies wird auch von den Entwicklern empfohlen \footnote{https://neo4j.com/blog/tuning-cypher-queries/ (07.08.19)}. \newline
In diesem Fall wird die Traversal API nicht genutzt, sondern nur die Core API. Eine Kernfunktion namens 'findNodes()' übernimmt die Suche nach einem Knoten mit angegebenen Eigenschaften, ohne dass der Nutzer das Vorgehen spezifizieren muss.  
\FloatBarrier
\begin{table}[h]
	\centering
		\begin{tabular}{ |p{3cm}|p{3cm}|p{3cm}|p{3cm}|  }
			\hline
			Ohne Where& Mit Where  &Core API\\
			\hline
			1,69   &  0,54  &0,29 \\
			\hline
		\end{tabular}
		\FloatBarrier
		\caption{Grundanfrage 1.2}
		\label{tab:Query1_2}
\end{table}
\FloatBarrier
Für Grundanfrage 1.3 wurde beobachtet, dass die semantisch Äquivalente Anfrage ca. 35\% schneller bearbeitet wird. Wie in den Erwartungen bereits beschrieben, ist dies auf die effiziente Implementierung des IN-Operators zurückzuführen. Da die schnellere, äquivalente Anfrage diesen Operator verwendet.
Die genauen Ergebnisse befinden sich in Tabelle	\ref{tab:Query1_3}.
\begin{table}[h]
	\centering
		\begin{tabular}{ |p{3cm}|p{3cm}|p{3cm}|p{3cm}|  }
			\hline
			Grundanfrage & Äquivalent&Core API\\
			\hline
			 13,36    & 8,66 &  3,2\\
			\hline
		\end{tabular}
		\caption{Grundanfrage 1.3}
		\label{tab:Query1_3}
\end{table}
\FloatBarrier
In der Grundanfrage 2.1 wurden bei der Traversierung bis zur Tiefe 2 ausgehend von Person1 alle Knoten des Graphen erreicht. Wie Tabelle \ref{tab:Query2_1} zeigt, besteht zwischen der Traversierung bis zur Tiefe 2 und Tiefe 3  eine minimaler Unterschied von durchschnittlich ca. 5,6\%. Entgegen der Vermutung besteht weder ein quadratischer Unterschied bei der Anfrage in Cypher, noch ein linearer Unterschied bei den Anfragen in mit der Core API. \newline 
Es wurde bestätigt, dass die Anfrage mit Tiefensuche signifikant schneller als die Anfrage mit Breitensuche ausgeführt wird, in diesem Fall ist die Anfrage für die Tiefe 2 ca. 84\% schneller. Dies wurde in Kapitel 3 durch den gegebenen Eigenschaften des Datensatzes begründet. 
\FloatBarrier
\begin{table}[h]
\centering
		\begin{tabular}{ |p{3cm}||p{3cm}|p{3cm}|p{3cm}|  }
			\hline
			Anfrage& Cypher & Breitensuche&Tiefensuche\\
			\hline
			Tiefe 2   & 224431    & 1190&  92\\
			Tiefe 3&    234132  & 1278   & 89\\
			\hline
		\end{tabular}
		\caption{Grundanfrage 2.1}
		\label{tab:Query2_1}
\end{table}
\FloatBarrier
Wie Tabelle \ref{tab:Query2_2} zeigt, besteht kein  signifikanter Unterschied zwischen Grundanfrage 2.2 und der äquivalenten Anfrage in Cypher. Beide Anfragen sind um ein vielfaches langsamer als die Anfrage, die die Core API verwendet. In der Core API Anfrage wurden 2 Ergebnismengen vom Java-typ 'Set' gebildet und durch den Aufruf der Funktion "removeAll()"  wurden die Elementen der einen Mengen aus der anderen Menge entfernt. Dies entspricht einer Realisierung von dem 'WHERE NOT' Ausdruck  in Java und besitzt offensichtlich eine bessere Performanz. Alle 3 Anfragen besitzen im Vergleich zu vorangegangen Anfragen eine extrem hohen Ausführungszeit und auch später beschriebene Anfragen besitzen meist eine deutlich geringere Zeit.
\FloatBarrier
\begin{table}[h]
	\centering
		\begin{tabular}{ |p{3cm}|p{3cm}|p{3cm}|p{3cm}|  }
			\hline
			Grundanfrage & Äquivalent&Core API\\
			\hline
			4.740.646    & 4.753.414 &  1.609\\
			\hline
		\end{tabular}
		\caption{Grundanfrage 2.2}
		\label{tab:Query2_2}
\end{table}
\FloatBarrier
Der kürzeste Pfade, welcher in Grundanfrage 2.3 untersucht wurde, besitzt die Länge 2. Wie die Grundanfrage 2.1 zeigt, werden bei einer Pfadlänge von 2 mit hoher Wahrscheinlichkeit alle Knoten erreicht. Wie in Tabelle \ref{tab:Query2_3} zu sehen, ist die Ausführungszeit der Anfrage in Cypher unter Verwendung des gegebenen Algorithmus, geringer als alle anderen Grundanfragen außer Grundanfrage 1.2. Erstmalig ist die Anfrage schneller als die alternative Formulierung in der Core API. Der relative Unterschied beträgt 37 \% und  der absolute Unterschied 3,1 ms. Durch die geringe absolute Differenz ist es nicht garantiert, dass der kürzeste Pfad mit der Verwendung von Cypher immer die schnellsten Schnittstelle darstellt. \newline
Die äquivalent Formulierung in Cypher besitzt die höchste beobachtete Ausführungszeit mit ca.2,3 Stunden. Diese Formulierung ist eine naiver Ansatz ohne Verwendung des Algorithmus und besitzt viele Berechnungsschritten, die durch den Algorithmus entfallen würden.
\FloatBarrier
\begin{table}[!htb]
	\centering
		\begin{tabular}{ |p{3cm}|p{3cm}|p{3cm}|p{3cm}|  }
			\hline
			Grundanfrage & Äquivalent&Core API\\
			\hline
			8,4    & 8.370.298 &  11,5\\
			\hline
		\end{tabular}
		\caption{Grundanfrage 2.3}
		\label{tab:Query2_3}
\end{table}
\FloatBarrier
Die Ergebnisse zur Grundanfrage 2.4 werden in Tabelle \ref{tab:Query2_4} dargestellt. Die einseitige Traversierung mit Breitensuche ist ca. 4,8\% langsamer als der gleiche Algorithmus bei einer bidirektionalen Traversierung. Beim Tiefensuche beträgt der Unterschied ca. 13 \%. In beiden Fällen sind die einseitigen Traversierungen wie erwartet langsamer als die bidirektionale Alternativen. Entgegen der Erwartungen ist die einseitige Anfrage mit Tiefensuche nicht die zweitschnellste Anfrage.  
Die zeitlichen Unterschiede zwischen den Anfragen sind relativ gering und das Verhalten bedarf ein weiteren Untersuchung, da signifikante Unterschiede wie in \ref{tab:Query2_1} erwartet wurden. Valide Aussagen über eine optimale Traversierung für diesem Graphen lassen sich bei diesen Unterschiede nicht treffen.    
\FloatBarrier
\begin{table}[!htb]
	\centering
	\begin{tabular}{ |p{3cm}|p{3cm}|p{3cm}|p{3cm}|  }
		\hline
		Breitensuche & Tiefensuche&bidirektionale Breitensuche &bidirektional Tiefensuche\\
		\hline
		 31050 & 31020    &  29558  &  26982\\
		\hline
	\end{tabular}
	\caption{Grundanfrage 2.4}
	\label{tab:Query2_4}
\end{table}
\FloatBarrier
TODO
\FloatBarrier
\begin{table}[h]
	\centering
	\begin{tabular}{ |p{6cm}||p{2cm}|p{2cm}|p{2cm}|  }
		\hline
		Anfrage& Core API & Cypher & OrientDB \\
		\hline
	Grundanfrage 1.1 (Eingehend)   &  64   & 215.383 & 3.495.459\\
	Grundanfrage 1.1 (Ausgehend)  & 160   & 212.620 & 1.674.758\\
	Grundanfrage 1.1 (Beides)  & 165  & 496.704 & 6.350.806\\
	Grundanfrage 1.2  & 0,29 & 0,54 & 0,17   \\
	Grundanfrage 1.3  & 3,2  & 8,66& 83.955   \\
	Grundanfrage 2.1 (Tiefe 2)  & 100 & 224.431 & 72.092   \\
	Grundanfrage 2.1 (Tiefe 3) & 65  & 234.132& TODO   \\
	Grundanfrage 2.2  & 1609 & 4.740.646 & TODO   \\
	Grundanfrage 2.3  & 11,5 & 8,4  & TODO   \\
		\hline
	\end{tabular}
	\caption{Grundanfrage 2.1}
\end{table}
\FloatBarrier
\section{Anwendungsszenario}
TODO
\section{Limitierungen und zukünftige Arbeit}
Die durchgeführte Evaluation hat nur eine Referenzdaten mit der OrientDB genutzt. Dies ist keine reine GDB und ist auf ein allgemeines Anwendungszenario spezialisiert. Für eine näherer Einordnung der Performanz von Neoj4 ist ein Vergleich mit einer reinen GDB wie beispielsweise der Sparksee Database\footnote{http://www.sparsity-technologies.com/ (28.08.19)} sinnvoll. Diese Datenbank konnte in dieser Evaluation durch Kommunikationsprobleme mit Sparsity-technologies nicht verwendet werden. Durch einen Vergleich mit der Sparksee Database könnte die Performanz von zahlreichen Graphalgorithmen   wie zum Beispiel Zentralitäts-Algorithmen überprüft werden. Dies ist mit OrientDB nicht direkt möglich, da keine genaue Implementierung der von Neo4j unterstützen Graphalgorithmen im vollen Ausmaß in der OrientDB gegeben ist. \newline 
Ein Vergleich zwischen Neo4j und einer relationalen Datenbank wie in \parencite{vicknair2010comparison} beschrieben, ist für eine weitere Beschreibung der Vor- und Nachteile einer Graphdatenbank sinnvoll. Dieser Vergleich wurde aus zeitlichen Gründen nicht vollzogen. OrientDB als Referenzdatenbank hat einen Vergleich zu einer anderen noSQL-Datenbank dargestellt und so ein erste Einschätzung zu der Performanz von Neo4j ermöglicht.      
\section{Fazit}
TODO
\section{Ackowledgment}
Danke an Lasse und Melf!
