% Chapter Template

\chapter{Theoretische Grundlagen} % Main chapter title

\label{Kaptiel3} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------
\section{Vorraussetzungen}
Im Folgenden werden alle Einstellungen, die für die Evaluation getroffen wurden beschrieben und begründet. 
\subsection{Datensatz}
Für das Experiment wurde ein selbsterstellter Datensatz gewählt, dieser wurde aus folgendem Code erstellt \footnote{https://github.com/McHektor123/BA/blob/master/Neo4j/InitNeo4j2.java} unter Verwendung der Parameter \footnote{https://github.com/McHektor123/BA/blob/master/Constants/CONSTANTS.java}. Die Datenbank besteht aus insgesamt 50.004 Entitäten, davon sind 4  vom Typ Action und  50000  vom Typ Person. Der Typ Action besitzt  2 Eigenschaften, mit den Namen 'name', welche einen String erwartet  und 'attribute', welche einen Int erwartet. Der Typ Person besitzt ebenfalls 2 Eigenschaften namens 'name' und 'attribute'. \newline
Es existieren insgesamt 4 Arten von Relationen: RELATIONSHIP1 und RELATIONSHIP2 bilden eine Relation von einer Entität des Typen Person zu einer Entität des Typen Action  und  RELATIONSHIP3 und RELATIONSHIP4 eine Relation von Person zu Person. Jede Person besitzt jeweils eine Relation vom Typen RELATIONSHIP1 und eine vom Typen RELATIONSHIP2, wobei die Ziel-Actions disjunkt sind. Pro Person existieren 2.500 Relationen vom Typen RELATIONSHIP3 und 2.500 Relationen vom Typen RELATIONSHIP4, welche jeweils zu einer anderen zufällig gewählten Person bestehen. Jede Person besitzt insgesamt 5002 Relationen. Da die Relationen als Kanten und die Entitäten als Knoten aufgefasst werden, besitzt der generierte Graph 50.004 Knoten und 250.100.000 Kanten mit einer phyischen Gesamtgröße von 8.8 GB. 
\subsection{Anfragen}
Für die Evaluation werden die Anfragen nach  \parencite{angles2012comparison}  in folgende Kategorien unterteilt: Nachbarschafts-Anfragen, Erreichbarkeits-Anfragen, Muster Passungs Anfragen und  Zusammenfassungen. 
\begin{enumerate}
	\item Nachbarschafts-Anfragen: Es wird geprüft, ob ein Knoten direkt über eine  Kante mit einem anderen Knoten verbunden ist oder  es werden alle Knoten die über eine bestimmte Menge an Kanten erreichbar sind zu einer Menge zusammengefasst, dies ist auch als k-nächste Nachbarn Problem bekannt. Beide Fälle lassen sich auch auf die Verbundenheit von Kanten über Knoten übertragen.
	\item Erreichbarkeits-Anfragen: Die Suche nach einem Pfad, welcher 2 Knoten bzw. Kanten verbindet. Wenn ein Pfad besteht ist der Ziel-Knoten von dem Start-Knoten aus erreichbar, bei einem ungerichteten Graphen gilt der umgekehrte Fall ebenfalls. Beim dem Auffinden von mehreren Pfaden, entsteht zudem das Problem des Finden des kürzesten Pfades. Bei einem gewichteten Graphen kann dieses Problem um die Suche des schnellsten/leichtesten Pfades  erweitert werden. 
	\item Muster Passungs Anfragen: Prüfen, ob der Graph ein Sub-Graph enthält, welcher Ähnlichkeiten zu einem gegebenen Muster oder zu anderen Sub-Graphen aufweist. Dies ist als Graph bzw. Sub-Graph Isomorphismus bekannt. 
	\item Zusammenfassungen: Diese Anfragen fassen eine Ergebnismenge zu einem Wert zusammen, dies ist durch Funktionen wie MAX,AVG oder COUNT ,aber auch dem Lesen von Eigenschaften des Graphen wie die Menge alle Knoten, realisiert. 
\end{enumerate}
Eine Anfrage kann dabei mehrere Kategorien beinhalten. In dem folgenden Experimenten werden hauptsächlich Anfragen der Kategorien 1,2 und 4 verwendet. Das gesamte Experiment besteht aus 2 Iterationen, in denen eine Menge von Anfragen gestellt und analysiert werden. \newline
\section{Erste Iteration}
Die erste Iteration besteht primär aus Nachbarschafts-Anfragen und Zusammenfassungen. Im folgenden Abschnitt werden die Grundanfragen der ersten Iteration und die Permutationen aus diesen vorgestellt. Ausgehend von den Grundanfragen werden Hypothesen zu dem erwarteten Verhalten aufgestellt.
\subsection{Grundanfragen}
 \textbf{Grundanfrage 1} wird beschrieben als:
\begin{Verbatim}[frame=single]
 MATCH (X:Person)-[:RELATIONSHIP3]-(Y) 
 WHERE X.attribute>=250 AND Y.attribute>=15  
 RETURN COUNT(DISTINCT(Y))
\end{Verbatim} 
Grundanfrage 1 findet alle Personen, die über RELATIONSHIP3 erreichbar sind, unter der Voraussetzung dass bestimmte Bedingungen für die Eigenschaften 'attribute' erfüllt sind. Bei dieser Anfrage wird die Richtung der Relation RELATIONSHIP3 zu ausgehend,eingehend und beides geändert und zusätzlichen werden diese Anfragen  semantisch äquivalent in der JAVA Core API unter Verwendung der Traversal API formuliert. Bei den 3 in Cypher formulierten Anfragen wird die Relation RELATIONSHIP3 durch die Relation RELATIONSHIP2 verändert. Insgesamt entstehen 9 Anfragen aus Grundanfrage 1. \newline \newline

 \textbf{Grundanfrage 2} wird beschrieben als: 
\begin{Verbatim}[frame=single]
MATCH (p:Person {name:'Person613'}) return p
\end{Verbatim} 
Diese Anfrage findet den Nutzer mit dem Namen "Person613". Sie wird dahingehend verändert, dass die Überprüfung des attributes 'name' in ein WHERE Prädikat verschoben wird und die Anfrage wird in der Core API formuliert. Aus Grundanfrage 2 entstehen insgesamt 3 Anfragen.\newline \newline

\textbf{Grundanfrage 3} wird beschrieben als: 
\begin{Verbatim}[frame=single]
MATCH (X:Person{name: 'Person1'})-[:Relationship3]->(n1) 
WITH COLLECT(n1) as n 
MATCH (Y:Person)-[:Relationship3]->(n1) 
WHERE n1 in n
RETURN COUNT(DISTINCT(n1))
\end{Verbatim} 
Diese Anfrage ermittelt alle gemeinsamen Nachbarn von Person1 und Person2, als Permutationen wird eine semantisch äquivalente Anfrage in den APIs und folgende in Cypher formuliert:
\begin{Verbatim}[frame=single]
 MATCH (X:Person{name: 'Person1'})-[:Relationship3]->(n1)
 		<-[:Relationship3]-(Y:Person{name: 'Person2'}) 
 RETURN COUNT(DISTINCT(n1))
\end{Verbatim} 
Für alle Anfragen, die mit der Traversal API geschrieben wurden, wird die Breadth-First-Methode für die Traversierungen verwendet. \newline
\subsection{Vermutungen}
Für \textbf{Grundanfrage 1} entstehen 3 Aspekte, welche betrachtet werden.
\begin{enumerate}
\item Das Verhalten beim Ändern der Richtung der Relationen
\item Die Performanzunterschiede zwischen der Cypher und den APIs
\item Die Unterschiede zwischen der Anfrage mit Verwendung von RELATIONSHIP3 und RELATIONSHIP2.
\end{enumerate}
Zum 1. Aspekt: besteht die Vermutung, dass die Ausführungszeit am höchsten ist, wenn die Relation in beide Richtung gelten kann und die Zeit ist minimal wenn die Relation als ausgehende Kante beschrieben wird. \newline
 Zum 2. Aspekt: wie in \parencite{raj2015neo4j} beschrieben, wird es empfohlen die APIs für eine erhöhte Performanz zu nutzen, da diese APIs low-level arbeiten und Cypher als high-lvl Sprache in Neo4j aufgefasst wird. Aus diesem Grund wird erwartet, dass die Performanz bei den verwendeten Anfragen deutlich höher ist, wenn die Java Core API mit Verwendung der Traversal API genutzt wird. \newline
Zum 3. Aspekt: Da jede Person eine Relation vom Typ RELATIONSHIP2 besitzt und insgesamt 2.500 vom Typ RELATIONSHIP3 wird Vermutet, dass die Anfragen mit der Relation RELATIONSHIP2 mindest um den Faktor 1.000 schneller ausgeführt werden. \newline \newline
Für \textbf{Grundanfrage 2} werden 2 Aspekte betrachtet .
\begin{enumerate}
	\item Die allgemeine Performanz und die entstehenden Unterschiede für das Suchen eines Knotens
	\item Das Verhalten, wenn die Abfrage, nach dem Namen in das WHERE-Prädikat verschoben wird.
\end{enumerate}
Zum 1. Aspekt: Wie bei der Grundanfrage 1 wird vermutet, dass der Java Core API eine höhere Performanz besitzt, insbesondere weil keine Traversal API verwendet wurde. Alle 3 Anfragen werden eine sehr schnelle Ausführungszeit besitzen, da besonders der Gebrauch von Indizes ein schnelles Finden durch Eigenschaften erlaubt. \newline
Zum 2. Aspekt: Da der Optimizer nach Angaben der Neo4j Inc. \footnote{https://neo4j.com/blog/introducing-new-cypher-query-optimizer/ 27.06.19} , die meisten Labels in das WHERE Prädikat verschiebt, sollte nur ein minimaler Performanzunterschied zwischen den beiden Anfragen bestehen. \newline \newline
Für \textbf{Grundanfrage 3} besteht ein Aspekt, der untersucht wird. 
\begin{enumerate}
	\item Ein Unterschied in der Laufzeit bei  semantisches Äquivalenz ein 
\end{enumerate}
Es wird vermutet, dass es kein signifikanten Unterschied zwischen den Laufzeiten gibt, falls Unterschied bestehen sollte, wird diese auf die Performanz des IN-Operator zurück geführt.



