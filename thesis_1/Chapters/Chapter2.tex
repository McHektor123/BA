% Chapter Template

\chapter{Testläufe der Evaluation} % Main chapter title

\label{Kapitel3} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------
\section{Vorraussetzungen}
Im Folgenden werden alle Einstellungen und Kategorisierungen, die für die Evaluation getroffen wurden, beschrieben. In den Testläufen werden Grundanfragen aufgestellt und Umformulierungen dieser vorgestellt. So entstehen mehrere Anfragen, die betrachtet werden.  
\subsection{Der verwendete Datensatz}
Für das Experiment wurde ein selbsterstellter Datensatz gewählt, welcher aus einem selbst geschriebenen Programm erstellt wurde \footnote{https://github.com/McHektor123/BA/tree/master/src}. Die Datenbank läuft im eingebetteten Modus von Neo4j und besteht aus insgesamt 50.004 Entitäten, welche die Objekte der Datenbank bilden. 4 der Entitäten sind  vom Typ Aktion und 50000 vom Typ Person. Der Typ Aktion besitzt 3 mit einem Index versehende Attribute, mit den Namen $name$, welches aus einem String besteht, $attribute$, welches aus einem Int besteht und $time$, welches aus dem Typen Date besteht. Der Typ Person besitzt ebenfalls 3 mit einem Index versehende Attribute namens $name$, $attribute$ und $time$. Jeder Wert der einzelnen Attribute tritt genau einmal auf, sodass alle Werte disjunkt sind. \newline
Es existieren insgesamt 4 Arten von Relationen: RELATIONSHIP1 und RELATIONSHIP2 bilden eine Relation von einer Entität des Typen Person zu einer Entität des Typen Aktion  und  RELATIONSHIP3 und RELATIONSHIP4 eine Relation von Person zu Person. Jede Person besitzt jeweils eine Relation vom Typen RELATIONSHIP1 und eine vom Typen RELATIONSHIP2, wobei die Ziel-Aktionen disjunkt sind. Pro Person wurden 2.500 Relationen vom Typen RELATIONSHIP3 und 2.500 Relationen vom Typen RELATIONSHIP4 generiert, da die Ziel-Personen nicht disjunkt sind, kommt es zu einer variablen Anzahl von zugehörigen disjunkten Relationen pro Person. Jede Person besitzt maximal 5002 Relationen. Da die Relationen als Kanten und die Entitäten als Knoten aufgefasst werden, besitzt der generierte Graph 50.004 Knoten und 250.100.000 Kanten mit einer physischen Gesamtgröße von 102,9 GB. 
\subsection{Anfragen} \label{Kategorien}
Für die Evaluation werden die Anfragen nach  Angles in folgende Kategorien unterteilt \parencite{angles2012comparison}: Nachbarschafts-Anfragen, Erreichbarkeits-Anfragen,Mustervergleichs-Anfragen und  Zusammenfassungen. 
\begin{enumerate}
	\item Nachbarschafts-Anfragen: Es wird geprüft, ob ein Knoten direkt über eine  Kante mit einem anderen Knoten verbunden ist oder  es werden alle Knoten die über eine bestimmte Menge an Kanten erreichbar sind zu einer Menge zusammengefasst, dies ist auch als k-nächste Nachbarn Problem bekannt. Beide Fälle lassen sich auch auf die Verbundenheit von Kanten über Knoten übertragen.
	\item Erreichbarkeits-Anfragen: Die Suche nach einem Pfad, welcher 2 Knoten bzw. Kanten verbindet. Wenn ein Pfad besteht ist der Ziel-Knoten von dem Start-Knoten aus erreichbar, bei einem ungerichteten Graphen gilt der umgekehrte Fall ebenfalls. Beim dem Auffinden von mehreren Pfaden, entsteht zudem das Problem des Finden des kürzesten Pfades. Bei einem gewichteten Graphen kann dieses Problem um die Suche des schnellsten/leichtesten Pfades  erweitert werden. 
	\item Mustervergleichs-Anfragen: Prüfen, ob der Graph ein Sub-Graph enthält, welcher Ähnlichkeiten zu einem gegebenen Muster oder zu anderen Sub-Graphen aufweist. Dies ist als Graph bzw. Sub-Graph Isomorphismus bekannt. 
	\item Zusammenfassungen: Diese Anfragen fassen eine Ergebnismenge zu einem Wert zusammen, dies ist durch Aggregations-Funktionen wie MAX,AVG oder COUNT ,aber auch dem Lesen von Eigenschaften des Graphen wie die Menge alle Knoten, realisiert. 
\end{enumerate}
Eine Anfrage kann dabei mehrere Kategorien beinhalten. Das gesamte Experiment besteht aus 3 Testläufen, in denen eine Menge von Anfragen gestellt und analysiert werden. 
\section{Erster Testlauf}
Der erste Testlauf besteht primär aus einfachen Nachbarschafts-Anfragen und Zusammenfassungen, um einen ersten Überblick von Neo4j zu erhalten. Im folgenden Abschnitt werden die Grundanfragen des ersten Testlaufes und Vergleichsanfragen der Grundanfragen vorgestellt. 
\subsection{Grundanfragen zu ersten Testlauf}
Das ist die \textbf{Grundanfrage 1.1.1}: 
\begin{Verbatim}[frame=single]
 MATCH (X:Person)-[:RELATIONSHIP3]->(Y:Person) 
 WHERE X.attribute>=250 AND Y.attribute>=15  
 RETURN COUNT(DISTINCT(Y))
\end{Verbatim} 
Grundanfrage 1.1.1 findet alle Personen, die über eine ausgehende RELATIONSHIP3-Kante erreichbar sind, unter der Voraussetzung, dass bestimmte Bedingungen für die Eigenschaften 'attribute' erfüllt sind. Es handelt sich um eine Erreichbarkeits-Anfrage.
Grundanfrage 1.1.2 verwendet die gleichen Bedingungen wie Grundanfrage 1.1.1 und betrachtet alle eingehenden statt ausgehenden Kanten. Grundanfrage 1.1.3 betrachtet sowohl ausgehende, als auch eingehende Kanten mit Verwendung der gleichen Bedingungen. In den Vergleichsanfragen werden diese 3 Grundanfragen mit der Relation RELATIONSHIP2 gestellt und zusätzlich semantisch äquivalent in der JAVA Core API unter Verwendung der Traversal API formuliert. Insgesamt entstehen 9 Anfragen aus Grundanfrage 1.1.1, dargestellt in Tabelle \ref{tab:Intro_Query2_1}.
\FloatBarrier
\begin{table}[h]
	\centering
	\begin{tabular}{ |p{5cm}||p{7cm}|p{3cm}  }
		\hline
		Anfrage& Name\\
		\hline
		Grundanfrage 1.1.1 &  Cypher - RELATIONSHIP3 ausgehend\\
		Grundanfrage 1.1.2 &  Cypher - RELATIONSHIP3 eingehend\\
		Grundanfrage 1.1.3 &  Cypher - RELATIONSHIP3 beides\\
		Vergleichsanfrage 1 &  Cypher - RELATIONSHIP2 ausgehend\\
		Vergleichsanfrage 2 &  Cypher - RELATIONSHIP2 eingehend\\
		Vergleichsanfrage 3 &  Cypher - RELATIONSHIP2 beides\\
		Vergleichsanfrage 4 &  Core API - RELATIONSHIP3 ausgehend\\
		Vergleichsanfrage 5 &  Core API - RELATIONSHIP3 ausgehend\\
		Vergleichsanfrage 6 &  Core API - RELATIONSHIP3 ausgehend\\
		\hline
	\end{tabular}
	\caption{Grundanfrage 1.1 und Vergleichsanfragen}
	\label{tab:Intro_Query2_1}
\end{table}
\FloatBarrier

\noindent Das ist die \textbf{Grundanfrage 1.2}: 
\begin{Verbatim}[frame=single]
MATCH (p:Person {name:'Person613'}) return p
\end{Verbatim} 
Diese Anfrage findet die Person mit dem Namen "Person613". In einer Vergleichsanfrage wird die Überprüfung des Attributes 'name' in ein WHERE Prädikat verschoben wird und die Anfrage  in der Core API formuliert wird. Es werden drei Anfragen verglichen, denen semantisch Grundanfrage 1.2 zu Grunde liegt.\newline \newline
Das ist die \textbf{Grundanfrage 1.3}: 
\begin{Verbatim}[frame=single]
MATCH (X:Person{name: 'Person1'})-[:Relationship3]->(n1) 
WITH COLLECT(n1) as n 
MATCH (Y:Person{name: 'Person2'})-[:Relationship3]->(n1) 
WHERE n1 in n
RETURN COUNT(DISTINCT(n1))
\end{Verbatim} 
Diese Anfrage ermittelt alle gemeinsamen Nachbarn von Person1 und Person2, so ist es eine Nachbarschafts-Anfrage mit einer genutzten Zusammenfassung. Folgende Vergleichsanfrage wird  in Cypher formuliert:
\begin{Verbatim}[frame=single]
 MATCH (X:Person{name: 'Person1'})-[:Relationship3]->(n1)
 		<-[:Relationship3]-(Y:Person{name: 'Person2'}) 
 RETURN COUNT(DISTINCT(n1))
\end{Verbatim} 
Für alle Anfragen, die mit der Traversal API geschrieben wurden, wird die Breitensuche für die Traversierungen verwendet. 
\subsection{Hypothesen zum ersten Testlauf}
Im Folgenden werden Hypothesen über das Verhalten der Grundanfragen zum ersten Testlauf aufgestellt. In der Auswertung werden diese Hypothesen überprüft. \newline \newline
Für \textbf{Grundanfrage 1.1.1} entstehen 3 Aspekte, welche betrachtet werden.
\begin{enumerate}
\item Die Performanzunterschiede zwischen den Grundanfragen 1.1.1-1.1.3
\item Die Performanzunterschiede zwischen Cypher und den APIs
\item Die Unterschiede zwischen der Anfrage mit Verwendung von RELATIONSHIP3 und RELATIONSHIP2.
\end{enumerate}
Zum 1. Aspekt: Die Ausführungszeit ist am höchsten bei Grundanfrage 1.1.3, da dort am meisten Pfade betrachtet werden müssen. Die Zeit ist minimal bei Grundanfrage 1.1.1, da dort die Anzahl der zu betrachtenden Pfade minimal ist. \newline
 Zum 2. Aspekt: Wie in \parencite{raj2015neo4j} beschrieben, wird es empfohlen die APIs für eine erhöhte Performanz zu nutzen, da diese APIs flexibler arbeiten und Cypher als hardware-ferne Sprache in Neo4j aufgefasst wird. Aus diesem Grund wird erwartet, dass die Performanz bei den verwendeten Anfragen deutlich höher ist, wenn die Java Core API genutzt wird. \newline
Zum 3. Aspekt: Da jede Person zwei Relationen vom Typ RELATIONSHIP2 besitzt aber maximal 2.500 vom Typ RELATIONSHIP3 werden die Anfragen mit der Relation RELATIONSHIP2 mindestens um den Faktor 1.000 schneller ausgeführt werden. Dies entspricht einer linearen Skalierung des Systems. \newline \newline
Für \textbf{Grundanfrage 1.2} werden 2 Aspekte betrachtet .
\begin{enumerate}
	\item Die allgemeine Performanz 
	\item Die entstehenden Unterschiede für das Suchen eines Knotens
	\item Der Vergleich zwischen Filtern in dem Where-Prädikat und der Match-Prädikat
\end{enumerate}
Zum 1. Aspekt: Alle 3 Anfragen werden eine sehr schnelle Ausführungszeit besitzen, da besonders der Gebrauch von Indizes ein schnelles Finden von Eigenschaften erlaubt. \newline
Zum 2. Aspekt: Wie bei der Grundanfrage 1.1 wird   die Anfrage mit der Java Core API eine bessere Performanz besitzen, insbesondere weil keine Traversal API verwendet wurde. \newline
Zum 3. Aspekt: Da der Optimierer, die meisten Bedingungen in das WHERE Prädikat verschiebt sollte nur ein minimaler bis nicht vorhandener Performanzunterschied zwischen den beiden Anfragen bestehen. \newline \newline
Für \textbf{Grundanfrage 1.3} wird nur ein Aspekt betrachtet.
\begin{enumerate}
	\item Der Unterschied der Laufzeiten bei semantisch äquivalenten Anfragen 
\end{enumerate}
Zum 1. Aspekt: Es wird vermutet, dass es keine signifikante Differenz zwischen den Laufzeiten der Anfragen in Cypher gibt, falls ein Unterschied bestehen sollte, wird diese auf eine effiziente Implementierung des IN-Operator zurückgeführt. Die Anfrage in der Core API sollte wie in Grundanfrage 1.1 die schnellste Bearbeitungszeit besitzen.

\section{Zweiter Testlauf}
Der zweite Testlauf verwendet die Nachbarschafts-Anfragen in einer höheren Tiefe, wodurch eine höherer Rechenaufwand simuliert wird. Es wird der Performanzunterschied zwischen der Breitensuche und Tiefensuche betrachtet und die bidirektionale Traversierung wird genutzt. Es werden komplexere Anfragen im Vergleich zum ersten Testlauf gestellt und es wird die Skalierbarkeit des Systems analysiert. Durch komplexere Anfragen, wird ein tieferes Verständnis der Funktionsweise von Neo4j erzeugt. 
\subsection{Grundanfragen zum zweiten Testlauf}
Das ist die \textbf{Grundanfrage 2.1.1}: 
\begin{Verbatim}[frame=single]
MATCH (p:Person{name :'Person1'})-[:RELATIONSHIP3*2]->(p1:Person) 
RETURN COUNT(DISTINCT(p1))
\end{Verbatim} 
Diese Anfrage findet die Anzahl aller Personen, die über die Relation RELATIONSHIP3 bis zur Tiefe 2 erreicht werden. Grundanfrage 2.1.2 sucht bis zur Tiefe 3. Es handelt sich um Nachbarschafts-Anfragen. Als Vergleichsanfragen werden beide Anfragen in den APIs mit der Breitensuche und Tiefensuche ausgeführt. Es ergeben sich 6 Anfragen.
\FloatBarrier
\begin{table}[h]
	\centering
	\begin{tabular}{ |p{5cm}||p{5cm}|p{3cm}  }
		\hline
		Anfrage& Name\\
		\hline
		Grundanfrage 2.1.1 &  Cypher - Tiefe 2\\
		Grundanfrage 2.1.2 &  Cypher - Tiefe 3\\
		Vergleichsanfrage 1 &  Tiefensuche - Tiefe 2\\
		Vergleichsanfrage 2 &  Tiefensuche - Tiefe 3\\
		Vergleichsanfrage 3 &  Breitensuche - Tiefe 2\\
		Vergleichsanfrage 4 &  Breitensuche - Tiefe 3\\
		\hline
	\end{tabular}
	\caption{Grundanfrage 2.1.1, 2.1.2 und Vergleichsanfragen}
	\label{tab:Intro_Query2_2}
\end{table}
\FloatBarrier
\noindent Das ist die \textbf{Grundanfrage 2.2}: 
\begin{Verbatim}[frame=single]
MATCH t=(p:Person{name :'Person1'})-[:RELATIONSHIP3]->(p1:Person)
-[:RELATIONSHIP3]->(p2)
WHERE NOT (p)-[:RELATIONSHIP3]->(p2) 
RETURN COUNT(DISTINCT(p2))
\end{Verbatim} 
Diese Anfrage findet alle Personen, welche über die RELATIONSHIP3 mit dem direkten Nachbarn  p1 verbunden sind, aber nicht mit Person p verbunden sind. Diese Anfrage ist eine Erreichbarkeits- und Mustervergleichs-Anfrage. Als Vergleichsanfragen wird eine semantisch äquivalente Anfrage in den APIs formuliert und es wird folgende Anfrage in Cypher formuliert:
\begin{Verbatim}[frame=single]
MATCH t=(p:Person{name :'Person1'})-[:RELATIONSHIP3*2]->(p1:Person)
WHERE NOT (p)-[:RELATIONSHIP3]->(p1)
RETURN COUNT(DISTINCT(p1))
\end{Verbatim} 
Das ist die \textbf{Grundanfrage 2.3}: 
\begin{Verbatim}[frame=single]
MATCH (p:Person{name :'Person1'}),(p1:Person{name :'Person42'}),
		path=shortestPath((p)-[:RELATIONSHIP4*..3]->(p1)) 
RETURN LENGTH(path)
\end{Verbatim} 
Diese Anfrage gibt die Länge des kürzesten Pfades zwischen die Personen Person1 und Person42 über die Relation RELATIONSHIP4 an, die maximale Länge ist hier auf 3 limitiert. Diese Anfrage ist eine Erreichbarkeits-Anfrage und nutzt den shortestPath Algorithmus von Cypher. Diese Anfrage wird erneut mit der Core API ausgeführt und als folgende Alternative in Cypher dargestellt: 
\begin{Verbatim}[frame=single]
MATCH (p:Person{name :'Person1'}),(p1:Person{name :'Person42'}),
		path=(p)-[:RELATIONSHIP4*..3]->(p1) 
RETURN LENGTH(path)
ORDER BY length(path) asc LIMIT 1
\end{Verbatim}
 \textbf{Grundanfrage 2.4} wird ausschließlich in der Core API formuliert. \newline
Die Anfrage traversiert solange über den Graphen, bis jeder Knoten einmal betrachtet wurde. Diese Anfrage wird mit der Breitensuche und Tiefensuche formuliert und wird zusätzlich durch die bidirektionale Traversierung mit Breiten - und Tiefensuche bearbeitet. Es ergeben sich 4 Anfrage. 
\subsection{Hypothesen zum zweiten Testlauf}
Es werden Hypothesen zu den komplexeren Grundanfrage aus dem zweiten Testlauf vorgestellt. Die Hypothesen werden ebenfalls in der Auswertung überprüft. \newline \newline
Für \textbf{Grundanfrage 2.1.1} werden folgende Aspekte betrachet: 
\begin{enumerate}
	\item Ein Unterschied zwischen der Traversierung zur Tiefen 2 und 3 
	\item Die Performanzunterschiede zwischen der Breitensuche und Tiefensuche
	\item Der relative Anteil an erreichten Personen im gesamten Graphen
\end{enumerate}
Zum 1. Aspekt: Die Bearbeitungszeit der Grundanfrage 2.1.2 wird mindestens doppelt so hoch sein wie wie die Zeit der Grundanfrage 2.1.1, da pro Knoten in der Ergebnismenge weitere 2500 Knoten betrachtet werden müssen. Für  Breitensuche und Tiefensuche besteht die Annahme, dass die Suche zu einer höheren Tiefe eine minimal höheren Rechenaufwand bedeutet, da beide Algorithmen eine Komplexität von O(V+E) besitzen. \newline
Zum 2. Aspekt: Bei der Erhöhung von Tiefe 2 zu Tiefe 3 steigt die Tiefe um 1 an, aber die Breite erhöht sich pro Element in der Tiefe 2 um 2500. Der Graph besitzt ausgehend von dem Knoten der Person1 eine relativ hohe Breite im Vergleich zu der Tiefe, dadurch wird die Anfrage mit der Tiefensuche signifikant schneller ausgeführt werden. Es entsteht die Möglichkeit einer schnellen und langsamer Ausführung einer Anfrage durch den Nutzer. \newline
Zum 3. Aspekt: Durch die Tiefe 2 können unter der Annahme, dass alle Personen über die RELATIONSHIP3 genau 2500 Ziel-Personen besitzen, maximal 6.250.000 Knoten erreicht werden. Da der Graph 50.000 Personen-Knoten besitzt, gibt es eine hohe Redundanz unter den Ziel-Personen. Durch die theoretisch hohe Anzahl von zu erreichenden Knoten bei der Tiefe 2 wird vermutet ,dass alle Personen bei der Traversierung zur Tiefe 2 erreicht werden. \newline \newline
Für \textbf{Grundanfrage 2.2} werden folgende Aspekte betrachet: 
\begin{enumerate}
	\item Ein Unterschied in der Laufzeit bei  semantischer Äquivalenz  
	\item Die allgemeine Performanz von dem Ausdruck $WHERE$ $NOT$.
\end{enumerate}
Zum 1. Aspekt: Zwischen den kleiner Anfragen wird Unterschied bestehen, da der Optimierer eine der beiden Ausdrücke in den anderen überführen wird und der Optimierer selbst Ressourcen beansprucht. \newline
Zum 2. Aspekt: Da eine weitere Anfrage im WHERE-Prädikat gestellt wird und beide Ergebnismengen verglichen werden, wird vermutet dass die Ausführungszeit sehr hoch ist. Durch die Eigenschaften der Parallelisierung wird die Anfrage in der Core-API um ein vielfaches schneller beantwortet werden. \newline  \newline
Für \textbf{Grundanfrage 2.3} werden folgende Aspekte betrachtet: 
\begin{enumerate}
	\item Die Berechnungszeit für den kürzesten Weg und die Länge von diesem
	\item Die Ausführungszeit in Cypher ohne Verwenden des Algorithmus
\end{enumerate}
Zum 1. Aspekt: Durch die Annahme, dass meisten Personen über RELATIONSHIP3/ RELATIONSHIP4 mit der Tiefe 2 erreicht werden können, wird davon ausgegangen dass der Pfad die Länge 1 oder 2 besitzen  wird. Die Ergebnisse werden mit den Ausführungszeiten von Grundanfrage 2.1.1 zusammenhängen und es wird keine höhere Ausführungszeit als in Grundanfrage 2.1.1 erwartet. \newline
Zum 2. Aspekt: Ausgehend von der Annahme,dass der Algorithmus lange optimiert wurde, wird die Anfrage mit dem Algorithmus eine signifikant schnellere Ausführungszeit aufweisen als die Anfrage ohne gegebenen Algorithmus. Die alternative Formulierung ist ein naiver Ansatz mit vielen aufwendigen Berechnungen, welcher eine große Ergebnismenge berechnet, die zu 1 Ergebnis minimiert wird. \newline \newline
Für \textbf{Grundanfrage 2.4} werden folgende Aspekte betrachtet:
\begin{enumerate}
	\item Der Unterschied zwischen der bidirektionalen Suche und einseitiger Suche mit dem selben Algorithmus
	\item Die relativen Berechnungszeit der 4 Traversierung-Methoden zueinander
\end{enumerate}
Zum 1.Aspekt: Die bidirektionale Suche wird schneller ausgeführt, da durch 2 parallele Pfade  weniger Berechnungsschritte zum Suchen eines Pfades, der  durch den gesamten Graphen verläuft, benötigt werden. \newline 
Zum 2. Aspekt: Da durch den gesamten Graphen ohne Abbruchbedingung traversiert wird, besitzen die beiden Suchalgorithmen die gleiche Komplexität. Beide Algorithmen werden dementsprechend bei einer einseitigen Ausführung die gleiche Ausführungszeit besitzen. Bei der bidirektionalen Traversierung wird vermutet, das die Tiefensuche schneller ausgeführt wird und insgesamt die schnellste Traversierung darstellen wird. Darauf wird die bidirektionale Breitensuche folgen und danach die beiden einseitigen Traversierungen. 
\section{Dritter Testlauf}
In dem dritten Testlauf werden alle Grundanfragen außer Grundanfrage 2.4 auf dem Datenbank Managment System OrientDB ausgeführt\footnote{https://orientdb.com/}. Die daraus resultierenden Werte dienen als Referenz für eine bessere Performanzeinschätzung. Es werden die schnellsten Laufzeiten der Grundanfragen mit den Bearbeitungszeiten der Anfragen in OrientDB verglichen. In OrientDB werden alle Anfragen in SQL formuliert und evaluiert. Für diesen Testlauf werden keine Hypothesen aufgestellt, die Performanzunterschiede von viele Faktoren wie interner Implementierungen abhängig sind. 
\subsection{OrientDB}
OrientDB ist eine noSQL,  Multi-Model Datenbank von dem Entwickler OrientDB Ltd. Die Multi-Model Eigenschaft beschreibt die Fähigkeit, Daten als Dokumente, Graph, Schlüssel/Wert-Modell oder als Objekte zu modellieren\footnote{http://orientdb.com/docs/3.0.x/misc/Overview.html (21.07.19)}. Die Daten werden mittels API für eine unterstützte Sprache oder mit den Anfragensprachen Gremlin oder SQL manipuliert. Als direktes Eingabe-Interface für Gremlin und SQL steht das OrientDB Studio für den Browser zur Verfügung.  Dieses DBMS ist der Community- und der Enterprise-Version verfügbar. Die Enterprise-Version verfügt über zusätzliche Features, die das Überwachen der Anfragen ermöglicht bzw. erleichtert. Da die Enterprise-Version über keine Features verfügt ,die nicht auf der Community-Version laufen, die Einfluss auf die  Performanz haben, wurde für dieses Experiment die Community Version gewählt. Die verwendete Version von OrientDB ist V 3.0.19. 
\subsection{Unterschiede von OrientDB und Neo4j}
Der primäre Unterschied ist, dass Neo4j eine reine Graphdatenbank ist und OrientDB eine Multi-Model Datenbank. Dadurch ist es OrientDB möglich beispielsweise Daten als Dokumente in die Datenbank einzupflegen oder die gesamte Datenbank als Graphen zu verwalten. Neo4j verwaltet alle Daten in einem reinem Graph. Dadurch ist  die Varianz an möglichen Daten in Neo4j eingeschränkt \parencite{fernandes2018graph}. Die beiden DBMS nutzen verschiedene Anfragesprachen und unterstützen unterschiedliche Programmiersprachen. Durch Java erstellt, besitzt der selbe Datensatz in der OrientDB eine physische Gesamtgröße von 43,3 GB und ist somit ca. 58\% kleiner als das Äquivalent in Neo4j.